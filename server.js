const express = require('express');
const app = express();
const bodyParser = require('body-parser');
const cors = require('cors');
const mongoose = require('mongoose');
const jwt = require('jsonwebtoken');
const validate = require('./server.validation');
const bcrypt = require('bcrypt');

const PORT = process.env.PORT || 4000;

// created constants that are used down for validation purpose
const allowCustomerProperties = ['customerName', 'email', 'contactNumber', 'streetAddress', 'postalCode', 'city', 'province', 'country', 'status'];
const allowProductProperties = ['productName', 'price', 'description', 'createdDate'];

// DB schema
const {customer, product, user} = require('./schema.model');

// for HTTPs cross site data sharing enable
app.use(cors());
// body parser for API
app.use(bodyParser.json());

// DB connection
mongoose.connect("mongodb+srv://brijesh:Gj5cf8510@tazwizcluster-3mkqd.mongodb.net/tazwiz_task?retryWrites=true&w=majority", { useNewUrlParser: true});
const connection = mongoose.connection;

connection.once('open', function(){
    console.log('MongoDB database connection established successfully');
})
// login
app.post('/user/login', (req, res) => {
   
    user.findOne({
        email: req.body.email.toLowerCase()
    })
    .then(usr => {
        if(usr){
            // compare hashed password
            if(bcrypt.compareSync(req.body.password, usr.password)){
                const loggedUserData = {
                    _id: usr._id,
                    firstName: usr.firstName,
                    lastName: usr.lastName,
                    email: usr.email
                }
                // generate user token
                let token = jwt.sign(loggedUserData, 'secret')
                res.json({'token':token});

            }else{
                res.json({'server_error': 'Wrong email address or password'});
            }
        }else{
            res.json({'server_error': 'Wrong email address or password'});
        }
    })
    .catch(err => {
        res.json({'server_error': "Something went wrong"});
    })
})
// select logged user prodile
app.get('/user/profile', (req, res) => {

   // decode token i.e generated by JWT at the time of login
    let decoded = jwt.verify(req.get('authorization'), 'secret')
    user.findOne({
        _id: decoded._id
    }).select('-__v -password')
    .then(usr => {
        if(usr){
            res.json(usr)
        }else{
            res.json({'server_error': "Something went wrong"});
        }
    })
    .catch(err => {
        res.json({'server_error': "Something went wrong"});
    })
})
// logout
app.get('/user/logout', (req, res) => {
   
    // decode token i.e generated by JWT at the time of login
    let decoded = jwt.verify(req.get('authorization'), 'secret')

    user.findOne({
        _id: decoded._id
    })
    .then(usr => {
        if(usr){
            res.json(usr)
        }else{
            res.json({'server_error': "Something went wrong"});
        }
    })
    .catch(err => {
        res.json({'server_error': "Something went wrong"});
    })
})
app.post('/user/register', (req, res) => {

    // check request body contains data
    if(Object.entries(req.body).length !== 0){
        const userData = {
            firstName: req.body.firstName,
            lastName: req.body.lastName,
            email: req.body.email.toLowerCase(),
            password: req.body.password
        }
        // validation checks
        const errors = validate.validation(req.body);
        const isValid = Object.keys(errors).length === 0;
            // is any error
            if(isValid){
                user.findOne({
                    email: req.body.email
                }).then(usr => {
                    if(!usr){
                        bcrypt.hash(req.body.password, 10, (err, hash) => {
                            userData.password = hash
                                user.create(userData)
                                    .then(usr => {
                                        res.json({status: usr.email+' registered'});
                                    })
                                    .catch(err => {
                                        res.json({'server_error': 'Something went wrong'});
                                    })
                            })
                    }else{
                        res.json({'server_error': 'User already exists'});
                    }
                    })
                    .catch(err =>{
                        res.json({'server_error': 'Soemthing went wrong'});
                    })
                }else{
                    res.json({'server_error': "Something went wrong"});
                } 
            }else{
                res.json({'server_error': "Something went wrong"});
            } 
})
app.get('/:model', (req, res) => {
    const dbModel = req.params.model
    // check request
    if(dbModel === 'customer'){
        getDataListFromDB (customer, res);
    }else if(dbModel === 'product'){
        getDataListFromDB (product, res);
    }
});
app.get('/:model/:id', (req, res) => {
    const id = req.params.id;
    const dbModel = req.params.model;
   // check request
    if(dbModel === 'customer'){
        getSingleDataFromDB(customer, id , res);
    }else if(dbModel === 'product'){
        getSingleDataFromDB(product, id, res);
    }   
});
app.delete('/:model/delete/:id', (req, res) => {
    const id = req.params.id;
    const dbModel = req.params.model;
    // check request
    if(dbModel === 'customer'){
        deleteDataToDB(customer, id , res);
    }else if(dbModel === 'product'){
        deleteDataToDB(product, id, res);
    }   
});

app.post('/:model/add', (req, res) => {
    const dbModel = req.params.model;
    // check request body contains data
    if(Object.entries(req.body).length !== 0){
        // check request
        if(dbModel === 'customer'){
            // mandatory fields checks
            const filteredBodyRequest = validate.filterBodyRequest(req.body, allowCustomerProperties);
            // validation checks
            const errors= validate.validation(filteredBodyRequest);
            const isValid = Object.keys(errors).length === 0;
            // is any error
            if(isValid){
                insertDataToDB(customer, req, res);
            }else{
                res.json({'server_error': "Something went wrong"});
            }
        }else if(dbModel === 'product'){
            // mandatory fields checks
            const filteredBodyRequest = validate.filterBodyRequest(req.body, allowProductProperties);
            // validation checks
            const errors = validate.validation(filteredBodyRequest);
            const isValid = Object.keys(errors).length === 0;
            // is any error
            if(isValid){
                insertDataToDB(product, req, res);
            }else{
                res.json({'server_error': "Something went wrong"});
            }
        }
    }else{
        res.json({'server_error': "Something went wrong"});
    } 
});
// udpate record by id
app.post('/:model/update/:id', (req, res) => {
    const dbModel = req.params.model;
    const id = req.params.id;
   
    // check request body contains data
    if(Object.entries(req.body).length !== 0){
        // check request
        if(dbModel === 'customer'){
            // mandatory fields checks
            const filteredBodyRequest = validate.filterBodyRequest(req.body, allowCustomerProperties);
            // validation check
            const errors= validate.validation(filteredBodyRequest);
            const isValid = Object.keys(errors).length === 0;
            //  is any error
            if(isValid){
                updateDataToDB(customer, id, req, res);
            }else{

                res.json({'server_error': "Something went wrong"});
            }
            
        }else if(dbModel === 'product'){
            // mandatory fields checks
            const filteredBodyRequest = validate.filterBodyRequest(req.body, allowProductProperties);
            // validation check
            const errors = validate.validation(filteredBodyRequest);
            const isValid = Object.keys(errors).length === 0;
            // is anyh error
            if(isValid){
                updateDataToDB(product, id, req, res);
            }else{
                res.json({'server_error': "Something went wrong"});
            }
        }
    }else{
        res.json({'server_error': "Something went wrong"});
    } 
   
});
// listening port
app.listen(PORT, function(){
    console.log("Server is running opn port: " + PORT);
})
// get all data
getDataListFromDB = (model, res) => {
    
    model.find(function(err, data){

        if(data.length === 0){
            res.json([]);
        }else if(data.length >= 0){
            res.json(data);
        }
        
    }).select('-__v');   
    
}
// get record by ID
getSingleDataFromDB = (model, id, res) => {
    
    model.findById(id, function(err, data){

        if(data){
            res.json(data);
        }else{
            res.json({'server_error': 'Something went wrong'});
        }

    }).select('-__v');
    
}
// insert record
insertDataToDB = (model, req, res) => {

    const insertData = new model(req.body);
    insertData.save()
            .then(data => {
                res.json({'success': 'Submitted successfully'});
            })
            .catch(err =>{
                res.json({'server_error': 'Failed to submit'});
            });

}
// update record
updateDataToDB = (model, id, req, res) => {

    model.findById(id, function(err, data){
       
        if(data){
            for (var key in req.body) { 
                data[key] = req.body[key];
            } 
            data.save()
                    .then(data => {
                        res.json({'success':'Changes saved successfully'});
                    })
                    .catch(err => {
                        res.json({'server_error': 'Failed to save changes'});
                    });
        }else{
            res.json({'server_error': 'Something went wrong'});
        }
       
    });

}
// delete record
deleteDataToDB = (model, id, res) => {

    model.findByIdAndRemove(id, (err, data) => {
        if(!err){
            res.json({'success': 'Deleted successfully'});
        }else{
            res.json({'server_error': 'Failed to delete record'});
        }
    });

}
